use std::ops::Add;

use num_traits::One;
use plotly::Scatter;

use crate::{config, plot, util};

/// Given a set of x and y values where the x value signify "bins" of data,
/// split the data into segments where the x values are continuous. To avoid the
/// risk of rounding errors, the x values should be integers. "Continuous" in this
/// context means that the x values are consecutive integers, i.e. separated by
/// exactly the value of <X as One>::one().
pub(crate) fn split_discontinuities<X, Y>(x: Vec<X>, y: Vec<Y>) -> Vec<(Vec<X>, Vec<Y>)>
where
    X: Copy + Add<X, Output = X> + One + PartialEq,
    Y: Copy,
{
    let mut result: Vec<(Vec<X>, Vec<Y>)> = Vec::new();

    if x.is_empty() || y.is_empty() {
        return result;
    }

    let mut segment_x = Vec::new();
    let mut segment_y = Vec::new();

    let one = X::one();
    let mut previous = x[0];
    segment_x.push(previous);
    segment_y.push(y[0]);

    for i in 1..x.len() {
        let current = x[i];
        if current != previous + one {
            result.push((segment_x.clone(), segment_y.clone()));
            segment_x.clear();
            segment_y.clear();
        }
        segment_x.push(x[i]);
        segment_y.push(y[i]);
        previous = current;
    }

    if !segment_x.is_empty() {
        result.push((segment_x, segment_y));
    }

    eprintln!("Split into {} segments", result.len());

    result
}

/// Apply common plot configuration to a Plotly trace object.
///
/// # Arguments
/// * `trace` - The Plotly trace object to apply the configuration to.
/// * `common_cfg` - The common plot configuration to apply.
/// * `line_color` - The color to use for the line of the trace.
///
/// # Returns
/// The trace object with the common configuration applied.
pub(crate) fn apply_common_plot_configuration(
    trace: Box<Scatter<f64, f64>>,
    common_cfg: &config::PlotCommon,
    line_color: &str,
) -> Box<Scatter<f64, f64>> {
    let mut trace = trace.name(&common_cfg.name);

    let trace_line = if let Some(line) = &common_cfg.line {
        line.into()
    } else {
        plotly::common::Line::new()
    };
    trace = trace.line(trace_line.color(line_color.to_owned()));

    if let Some(visible) = &common_cfg.visible {
        trace = trace.visible(visible.into());
    }

    if let Some(mode) = &common_cfg.mode {
        trace = trace.mode(mode.into());
    }

    if let Some(x_axis) = &common_cfg.x_axis {
        trace = trace.x_axis(x_axis);
    }
    if let Some(y_axis) = &common_cfg.y_axis {
        trace = trace.y_axis(y_axis);
    }

    trace
}

/// Get the color to use for the line of a trace. This either comes from the
/// configuration, or is generated by the color generator in the plot context.
pub(crate) fn get_line_color<'a>(
    context: &plot::PlotContext,
    common_cfg: &'a config::PlotCommon,
) -> &'a str {
    if let Some(line) = &common_cfg.line {
        if let Some(color) = &line.color {
            color.as_str()
        } else {
            context.color_gen.borrow_mut().next()
        }
    } else {
        context.color_gen.borrow_mut().next()
    }
}

/// Aggregate and segment a set of data points according to the aggregation
/// configuration in the common plot configuration. If no aggregation is
/// configured, the data is returned as a single segment. Otherwise,
/// the data is aggregated according to the configuration and then split
/// into segments where the x values are continuous.
pub(crate) fn aggregate_and_segment(
    common_cfg: &config::PlotCommon,
    timestamp: Vec<i64>,
    value: Vec<u64>,
) -> Vec<(Vec<i64>, Vec<f64>)> {
    if let Some(ref aggregation) = &common_cfg.aggregation {
        let binning_function = util::get_grouping_function_for_time_window(&aggregation.size);
        let (bin_indices, mut bin_values) =
            util::group_by_x(&timestamp, &value, aggregation.min_count, &binning_function);

        util::sort_bins_inplace(&mut bin_values);
        let statistics_per_bin = util::get_statistics_per_bin(&bin_values);
        let value = util::extract_statistic(&statistics_per_bin, &aggregation.mode);

        let segments = split_discontinuities(bin_indices, value);

        let unbinning_function = util::get_ungrouping_function_for_time_period(&aggregation.size);
        util::ungroup_segments_by_x(&segments, &unbinning_function)
    } else {
        vec![(timestamp, value.iter().map(|x| *x as f64).collect())]
    }
}
